// // console.log('test');

// let one;  // 변수 선언은 했고, 값은 무엇을 !가리키지는! 않은 상태
// // 이 둘을 이어붙이는 것이 대입 연산자(=) -> 값을 가리킨다
// // => 식별을 위해서 값과 변수를 !대입!하는 과정을 통한다

// let test = 1; 
// // 변수 선언과 동시에 값을 가리켰다 === 초기화(init)
// // 데이터 1이라는 값이 할당이 되면 RAM이라는 메모리에 일단 담긴다, !식별할 방법!이 필요 === 변수의 큰 의미

// 1;  // 활용도가 없을 뿐 값은 존재하는 상태, 활용이 아직 안된 상태
// // 변수를 왜 쓰느냐 때문 => 데이터 숫자 타입 1이란 저 값을 변수를 안 쓰면 쓸 방법이 없음

// // console.log(one);

// // const two;
// // console.log(two);
// // SyntaxError: Missing initializer in const declaration
// // => 작성법 에러: 상수 선언할 때 값이 초기화가 안되서 못 찾았어
// // 에러가 났다 === 해결만 한다면 무결해진다
// // 변수는 var, let, const 세 가지가 있고, 값을 가리키게 하는 방법
// // var는 너무 유연, js가 욕먹는 1등 공신 -> 오류를 못 찾는다, hoisting 문제도 있음

// // let 중괄호 안에서만 효력을 발생하는 var보다 명확한 구석이 있음
// // -> 다루고자 하는 변수가 있다면 

// // 가장 권장되는 것 === const(사용빈도 98%) -> !상수!를 많이 쓴다, 변하지 않게 붙잡아가면서 작업하겠다란 암묵적인 관습
// // 문서 api는 바꿀일이 없다, get할 때는 무조건 const
// // 에러가 나게끔 만드는 것이 목적, 어설프게 맞아 떨어지면 이게 문제

// // 에러에 익숙해지는 것
// // 상수 선언
// // => 선언만 하면 안되고 값도 같이 할당을 해줘야 한다 === 변수 선언과 동시에 값 할당

// const two = 1;
// // console.log(two);

// // console.log(1 === '1'); // false
// // 문자열 1과 정수 1이 같다고 하는 js의 가장 큰 버그
// // 비교 연산자
// // ===: !일치! 연산자 => 데이터 타입까지 모두 체크를 한다
// // ==: !동등! 연산자 => 옛날에 쓰던 방식, 문자 숫자 구분을 못함, 완전 비권장, 에러가 나지 않음

// let a=1;
// let b='2아진';
// // console.log(a === b);
// // console.log(typeof a === typeof b);

// // 데이터 타입을 바꾸는 행위 => !형변환!
// // 많이 쓰는 이유 === 사용자가 입력하는 데이터는 숫자일리가 없다
// // 사용자의 입력 행위(로그인 같은)는 거의 대부분 문자열로 input행위가 일어남

// console.log(typeof b);
// // 대표적인 형변환의 특징 
// // let change = Number(b);
// let change = String(b);
// console.log(typeof change);

// // js가 지원하는 !형변환! 메서드가 있다
// // 1. 대문자가 첫번쨰로 들어오는 파스칼 케이스로 됨
// // String();
// // Number(); === 원시 래퍼객체
// // NaN === Not a Number
// // 문자열을 숫자로 바꾸는 경우가 굉장히 많음
// // *mdn 자세히 보기
// // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Number
// // 키보드는 문서 자체가 문자로 이뤄진 데이터다보니 생기는 현상

// let chae = null;
// // null이라는 값은 존재는 하지만 비어있는 값, 프로그래밍에만 있는 개념 !빈 공간!
// // 아직 값이 정해지지 않았다(console.dir();했을 때 비어있는 부분들)

// console.log(typeof chae); // object
// // null이라는 값은 number, string, object 동등한 레벨 데이터타입인데
// // 타입 체크를 하면 object를 뱉어내는 이상한 현상 === 자바스크립트의 !버그!
// // 못 없애는 버그 중의 하나

// // null vs " "(문자열, 데이터 타입 선언이 끝난 상태)
// // 비어있는 값과 비어있는 문자열

// let arr = ['피카츄', '라이츄', '파이리', '꼬부기'];
// console.log(typeof arr);  // object
// !버그가 아니다! === array는 사실 객체다
// 객체에서 순서만 필요할 때 쓰려고 나눠놓음
// array이라고 뜨는 방법은 없을까?
// console.log(Array.isArray(arr));  //true와 같은 boolean 타입으로 갖고 와짐
// Array라는 객체를 .isArray라는 메서드로 arr을 객체로 불러와줄 수 있는 방법

//=> 배열의 원래 본체는 객체다
// 그래서 타입체크를 다르게 해놓은 것이 있다
// === .isArray(); 메서드: is로 시작하는 메서드는 암묵적으로 boolean으로 return하게끔 돼있음
// 작성하는 함수에서도 bool로 리턴값을 받고 싶으면 is를 사용하는 경우가 많다

//---------------------------------------------------------------------------------------

/* 데이터 타입 => 숫자, string, null, undefined, object(array는 함께 객체로 묶임), boolean */
// typeof라는 것만 알면 구분을 계속 할 수 있게 됨

let text = '나는 잘생긴 공욱재다';
console.log(text.length); // 문자열도 배열이다
// string은 순서가 있다는 말, 문자 형태의 배열, 배열접근이 가능하다
// => 문자(char): 말 그대로 문자 한 글자
// charset -> 문자를 인코딩해주는 방식
console.log(text[7], text[8], text[9]);
// 글씨가 하나씩 나타나는 인터랙션이 가능


//=========================================================================================
// 1. 버그가 많다
// 2. 배열이 객체