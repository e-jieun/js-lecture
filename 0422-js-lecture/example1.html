<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="root">
    <div></div>
  </div>
  <!-- 어려워도 극복해보기 -->
  <script>
    // 아이디 값이 root인 놈을 가져올래
    const root = document.getElementById('root');
    console.dir(root);
    // children이 배열이었다
    // children 요소 확인
    console.log(root.children);
    console.log(root.children[0]);
    // => div를 가리킨다
    // 객체를 사용해보니
    /* 1. 자식관계라는 것은 사실은 부모격의 객체에서 어떤 프로퍼티(속성값)의 배열로 들어가는 것 뿐이었다 */
    // 모든 게 객체였구나, 관계가 있다? -> 객체를 의심한다
    console.dir(root.children[0]);
    // 인스턴스? => 피그마의 컴포넌트 복붙하면 생기는 인스턴스처럼 모든 스타일 속성이 똑같이 자식 노드에 상속되어 있었음
    // 키: 값; 중에 값 부분이 키:""; => string 타입이어야만 한다, 무조건 문자열로 바꾸거나 받거나
    // 가져올 때도 문자열로 가져온다
    
    // 새로운 데이터 타입
    // 문자열, 숫자, 배열, 객체, 불리언, null(?), undefinded(?)
    // null: !값이 있어야 할 자리에 무언가 비어있다!, 존재하지만 값이 없다(에러가 아니라 값을 넣어주거나 안쓰거나), 의도해서 값을 비웠다
    // undefineded: 정의되지 않았다, 의도하지 않게 값이 없다
    // root.children[0].textContent = textArray[0];
    // html 마크업을 할 때 우리가 문자(char)를 작성하면 자바스크립트는 div라는 객체에 textContent라는 키 값에 할당(assignment)해주는 것
    // <tag>
      // element node, attribute node, text node <-를 직접 쓰게 됐다
      // === 글씨를 바꿀 수도 있다
      
      // let changeText = textArray[1];
      // textContent를 changeText로 재할당
      
      /* 이거 어차피 문자열 꾸러미인데 그냥 한번에 변수에 저장하면 안되나? */
      // => 배열을 선언
      const textArray = ['안녕하세요 행복한 금요일이네요!', '내일은 토요일이다!', '모레는 일요일이다', '글피는 으아아아아', '화요일은 화장품 사러가야지'];
      
      document.body.style.width = '100vw';
      document.body.style.height = '100vh';
      document.body.style.backgroundColor = 'salmon';
      
      // *알고리즘 구상 => 문서를 클릭할 때마다 텍스트가 바뀌었으면 좋겠어
      // 1. 텍스트 목록이 필요할 것 같네?
      // 2. 목록은 배열이 순서대로 쓴다던데?
      // 3. 잠깐만 순서는 숫자니까 더하기 1만 하면 되겠네?
      // 4. 숫자는 어떻게 덧셈시킬까?
      // 5. 숫자 변수를 하나 만들어주면 되겠다
      
      
      let indexValue = 0;
      // body
      // 두번째 매개변수에 function 넣어줌
      // addListender('wheel', function(){});이 들어가면 스크롤하면 계속 반복됨
      document.body.addEventListener('wheel', function(){
        // root의 textContent 값이 빈칸이면 참
        if(root.children[0].textContent === ''){
          // console.log('test');
          // => 디버깅한 부분

          // document.body.addEventListener('click', function(){

          // })에서 작성한 부분 === 아래의 부분
          // root.children[0].textContent = textArray[1];
          // => 문서의 body 부분을 클릭하면 두번째 인수로 자리잡혀있는 함수 내용을 실행시켜줘
          // 함수 내용이 뭐냐면 사람들이 이걸 알고리즘이라고 부르더라
          // root에 있는 자식에 0번째가 있을 거 아마 그것도 태그일 것이다, 거기에 text node 키에 변수 문자열 '재할당해줘';
          
          // html구조를 바꾸는 것 js의 권리
          
          // textContent를 textArray[0]번째로 값을 재할당해줘라
          root.children[0].textContent = textArray[indexValue];
        } else{
          // 아닌 것이 참일 경우
        // indexValue++; => 1씩 증가
        indexValue++;
        // 숫자 1을 증가시켜준 다음에 다시 재할당
        root.children[0].textContent = textArray[indexValue];
        // !오타났었음
        console.log(indexValue);
      }
      // 마지막 인덱스 4번이랑 같으면
      if(indexValue === textArray.length-1){
        // 다시 indexValue = 0;으로 바꿔줘
        indexValue = 0;
        // 이 숫자는 무한대로 반복할 수 있는 알고리즘이 필요했던 것
        // 번호가 필요하다 === 배열이란 목록이 필요하다

        // =============================================>
        // 1. 배열에는 데이터가 순서대로 들어가 있다
        // 2. 이벤트를 시작하면 숫자 +1 더해진다
        // 3. 숫자는 어딘가 변수에 대입되어있다
        // 4. 배열의 마지막 원소 순서보다 숫자가 커지면 다시 0으로 바꾼다
        // + 문서의 내용
        // === 위의 작업
      }
    })
  </script>
</body>
</html>