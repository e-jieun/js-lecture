<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* #root{
      width: 100vw;
      height: 100vh;
      background-color: salmon;
    } */
    /* 프로그래밍 vs 디자인의 접점
    1. 객체와 배열을 계속해서 연습한다
    2. 내장 함수는 이미 규칙이 정해져 있다(우리가 만든게 아니기 때문) 
    => mdn 사이트를 간다, 에디터의 힌트를 얻는다
    3. console을 찍어본다
    
    브라우저가 마크업과 프로그래밍 언어를 해석하는 순서가 있다
    === 렌더링 알고리즘
    1. html을 먼저 읽는다 -> 데이터를 표시하는 구조이기 때문에
    2. 제어가 우선순위 앞에 있다 => css 읽기 전의 값을 본다
    3. 마지막에서야 css를 읽어들인다

    === js를 쓰면 css가 뒷전이 된다
    그래서 여기서 console에서 width가 빈칸으로 나왔음

    */
  </style>
</head>
<body>
  <div id="root">

  </div>
  <script>
    // 선택자와 비슷한 식별자를 만들어 준다
    // getElementById() 내장 함수는 인수(argument)로 문자열(string)로만 받는 규칙이 들어있다 

    // 인수를 넣기 위해 괄호를 작성하면 에디터가 힌트를 준다
    const root = document.getElementById('root');
    // =>값을 가져온다는 의미의 getter 방식을 위에서 사용하고, === 가져온다
    // const data = document.querySelector('#root');

    // 작성법은 다르지만 리턴은 똑같이 된다
    console.log(root);
    // console.log(data);
    
    // 브라우저는 해석하는 순서가 있고 복잡하다 => console.dir() => 확인하는 절차만 꼼꼼하게 한다면 원인을 찾을 수 있다  
    // #root variable declaration
    let back = 200/2;

    // #root style
    root.style.width = back+'vw';
    root.style.height = back+'vh';
    root.style.backgroundColor = 'salmon';
    
    // 구조를 보겠다, 객체를 찾는다
    console.dir(root);
    // 만약에 member 배열에 이미지를 넣으면 클릭할 때마다 바뀌는 슬라이드되는 이미지를 만들 수 있을 것이다
    // count해서 배열의 순서를 0부터 꺼내와준다
    const member = ['손만충', '장준형', '임소희', '이누리'];
    
    // count해주겠다
    let count = 0;
    // 첫번쨰 인수로 타입 작성
    // EventTarget을 써보면 딱 타겟을 정해서 이벤트를 실행시킬 수 있다
    // https://developer.mozilla.org/ko/docs/Web/API/EventTarget/addEventListener
    root.addEventListener('click', function(){
      // 변수 result는 100*2 = 200이다
      let result = back*2;
      let darkGray = 'darkgray';
      // width: 200vw;
      root.style.width = result+'vw';
      // height: 200vh;
      root.style.height = result+'vh';
      // bgc:darkgray
      root.style.backgroundColor = darkGray;
      // textContent
      // === 로그인 시 환영인사 같은 것
      // 스타일이 아닌 경우도 있다, 객체 프로퍼티만 찾으면 적용할 수 있다
      // 
      root.textContent = member[count]+'님 반가워요';
      // 문장이 끝나면 카운트를 +1 해줘라
      count += 1;
      // === count = count+1;
      // 만약에 카운트가 멤버 배열 길이-1보다 크면
      // !인터랙션의 기본적인 알고리즘!
      // 카운트한 인덱스의 숫자가 멤버의 마지막 순서의 숫자보다 크면 
      if(count > member.length-1){
        // 다시 카운트를 0으로 돌려줘
        // => 배열에 이미지를 넣으면 이미지를 클릭하면 반복하는 것에서 사용한다
        // === 웹사이트의 슬라이드 이미지를 만들때 사용할 수 있는 알고리즘
        count = 0;
      }
    });
    // => 값을 할당한다는 의미의 setter를 활용한 것 = setting === 만들어준다
    </script>
</body>
</html>