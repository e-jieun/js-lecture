<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="one"></div>
  <div id="two">
    <section></section>
    <section></section>
    <section></section>
    <section></section>
    <section></section>
    <section></section>
    <section></section>
    <section></section>
    <section></section>
    <section></section>
  </div>

  <script>
    const one = document.querySelector('#one');
    const twos = document.getElementById('two').children;
    const three = document.querySelectorAll('#two > section');
    // !배열처럼 표기법을 써왔지만 사실은 배열이 아니다
    // 문서 데이터(DOM API) -> 순서값을 가진 값의 묶음
    // -> HTMLCollection(HTML 모음)
    // -> NodeList(마디목록)
    // : 배열처럼 인덱스와 랭스를 가지고 있지만 데이터 타입은 배열이 아니다
    // 유사 배열 객체(array like object): 배열처럼 보이는 객체, 자바스크립트 엔진은 값의 모음과 배열을 구별하고 있다

    console.log(one);
    console.log(twos);
    console.log(typeof twos);
    console.log(three);

    // !코어 메서드 중에 from이라는 것이 있다 
    // 배열처럼 보이는 데이터를 배열처럼 쓰겠다 === 배열로 취급을 하겠다
    const four = Array.from(three);
    // 배열메서드를 쓸 줄 안다
    // ES6에서만 지원한다 => .slice.call();(예전의 방식) === Array.from(); -> !값들의 모음을 다 잘라서 다시 배열 자리에 넣어!
    console.log(Array.isArray(four)); //  배열이 맞는지 타입체크 === true
    console.log(four);  // object로 반환한 이유는 배열의 근원인 객체를 반환하기 때문이다

  </script>
</body>
</html>